/* Контекст вызова. This. */

'use strict';

/* Контекст вызова - это то, что окружает функцию и в каких условиях она вызывается. */

/* Функция может вызываться четыремя способами и в каждом контекст вызова отличается */

/* 1) Обычная функция: this = window, но если стоит use strict = undefined */
function showThis() {
    console.log(this);
}

showThis();
/* Получаем window. Если функция просто запускается таким образом. Когда мы используем в ней контекст, то этот контекст  будет ссылаться на глобальный объект window. Это правило верно для обычного кода без строгого режима */
/* Но если включить строгий режим this будет undefined */


function showSecond(a, b) {
    function sum() {
        console.log(this)
        return a + b;
    }
    console.log(sum());
}

showSecond(4, 5);

/* 2)  Контекст у методов объекта - сам объект */
const obj = {
    a: 20,
    b: 15,
    sum: function() {
        console.log(this);
        function shout() {
            console.log(this);
        }
        shout();
        /* shout() будет undefined потому что это простой вызов функции, он не относится к методу. */
     }
};

obj.sum(); 
/* Если используем метод внутри объекта, то контекст вызова всегда будет ссылаться на объект  */

/* 3) Функции-конструкторы. this в конструкторах и классах - это новый экземпляр объекта */
/* User - Функция-конструктор, когда будет вызвана, она создаст новый объект
this.name, this.id, this, human - свойства, которые обращаются к this и записываем какое-то значение */
function User(name, id) {
    this.name = name;
    this.id = id;
    this.human = true;
}

let dmitriy = new User('Дмитрий', 25);

/* 4) Ручное присвоение this любой функции (call, apply, bind) */
function sayName(surname) {
    console.log(this);
    console.log(this.name + surname);
}

const user = {
    name: "Эмили"
};

/* Для вызова функции на конкретном объекте есть два метода call() apply() (разницы между ними нет, только синтаксис) */
sayName.call(user, "Джонсон");
sayName.apply(user, ['Джонсон']);
/* Разница начинается только когда функция обретает какие-то аргументы */

/* bind() создаёт новую функцию связанную с определённым контекстом */
function count(num) {
    return this*num;
}

const double = count.bind(2);

console.log(double(3));
console.log(double(13));

// ------------------------------------------------------------------------
/* Проверка на кнопке с классом btn_this */
const btn = document.querySelector('.btn_this');

btn.addEventListener('click', function() {
    console.log(this);
    this.style.backgroundColor = '#FFE4C4';
});

/* Получаем саму кнопку в консоль <button class="btn_this">Контекст вызова this</button> */

/* Когда обработчик события, который идёт как callback функция записан в классическом режиме function(), контекст вызова будет сам элемент на котором произошло событие (тоже самое произойдёт если использовать e.target) */

/* У стрелочной функции нет своего контекста вызова (this), она всегда его будет брать у своего родителя (если родителя нет - будет undefined) */
/* Если стрелочная функция не работает, то используем e.target */
/* Стрелочные функции очень часто используются для модификации каких-то элементов прямо здесь на месте */
const objSec = {
    num: 5,
    sayNumber: function() { 
        const say = () => {
            console.log(this);
        };

        say();
    }
};

objSec.sayNumber(); 
/* Здесь this будет ссылаться на сам объект objSec, поскольку он является родителем */

// ------------------------------------------------------------------------------------------------------------------
/* Стрелочная функция создана для укорачивания кода. Если код вмещается на одну строчку, то его можно сократить */

/* Обычный вариант */
const doubles = (a) => {
    return a * 2;
};

/* Сокращённый вариант */
const doublesS = (a) => a * 2;

/* Если есть только один аргумент */
const doublesT = a => a * 2;

console.log(doubles(4));
console.log(doublesS(4));
console.log(doublesT(4));